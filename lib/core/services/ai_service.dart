// lib/core/services/ai_service.dart

import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:google_generative_ai/google_generative_ai.dart';
import '../enums/ai_personality.dart';
import '../constants/ai_prompts.dart';
import '../config/api_config.dart';
import '../../data/models/chat_message.dart';
import 'emotion_detection_service.dart';
import 'conversation_state_service.dart';
import 'api_key_manager.dart';

class AIService extends ChangeNotifier {
  GenerativeModel? _model;
  ChatSession? _chatSession;
  
  AIPersonality _currentPersonality = AIPersonality.tutor;
  final List<ChatMessage> _conversationHistory = [];
  bool _isLoading = false;
  String _errorMessage = '';
  
  // Track if a document is loaded
  bool _hasDocumentLoaded = false;
  String? _loadedFileName;
  
  // Store document notes generated by AI
  String _documentNotes = '';
  Map<String, String> _definitions = {};

  // Rate limiting
  DateTime? _lastRequestTime;
  int _requestCount = 0;

  final EmotionDetectionService _emotionDetection = EmotionDetectionService();
  ConversationStateService? _stateService;

  // Getters
  List<ChatMessage> get conversationHistory => List.unmodifiable(_conversationHistory);
  bool get isLoading => _isLoading;
  bool get hasDocumentLoaded => _hasDocumentLoaded;
  AIPersonality get currentPersonality => _currentPersonality;
  String get errorMessage => _errorMessage;
  String? get loadedFileName => _loadedFileName;
  ConversationStateService? get stateService => _stateService;
  String get documentNotes => _documentNotes;
  Map<String, String> get definitions => Map.unmodifiable(_definitions);

  // ========== Initialize ==========
  Future<void> initialize() async {
    try {
      final apiKey = ApiConfig.geminiApiKey;
      if (apiKey.isEmpty) throw Exception('API Key is empty');

      _model = GenerativeModel(
        model: ApiConfig.geminiModel,
        apiKey: apiKey,
        generationConfig: GenerationConfig(
          temperature: ApiConfig.temperature,
          maxOutputTokens: ApiConfig.maxOutputTokens,
        ),
      );
      
      _startNewSession();
      notifyListeners();
      
    } catch (e) {
      _errorMessage = 'Initialization failed: $e';
      notifyListeners();
    }
  }
  
  void _startNewSession() {
    if (_model != null) {
      _chatSession = _model!.startChat();
    }
  }

  // ========== Rate Limiting ==========
  Future<void> _checkRateLimit() async {
    final now = DateTime.now();
    
    if (_lastRequestTime != null) {
      final timeSinceLastRequest = now.difference(_lastRequestTime!);
      
      // Reset counter if more than 1 minute has passed
      if (timeSinceLastRequest > ApiConfig.rateLimitWindow) {
        _requestCount = 0;
      }
      
      // Check if we're hitting rate limits
      if (_requestCount >= ApiConfig.requestsPerMinute) {
        final waitTime = ApiConfig.rateLimitWindow - timeSinceLastRequest;
        if (waitTime.isNegative == false) {
          if (kDebugMode) {
            print('‚è≥ Rate limit reached. Waiting ${waitTime.inSeconds}s...');
          }
          await Future.delayed(waitTime);
          _requestCount = 0;
        }
      }
      
      // Add small delay between requests (4 seconds for free tier safety)
      if (timeSinceLastRequest.inSeconds < 4) {
        await Future.delayed(const Duration(seconds: 4) - timeSinceLastRequest);
      }
    }
    
    _requestCount++;
    _lastRequestTime = now;
    
    // Record usage in API Key Manager
    ApiKeyManager.instance.recordUsage(ApiConfig.geminiApiKey);
  }

  // ========== Handle Quota Errors with Auto-Retry ==========
  Future<T> _executeWithRetry<T>(Future<T> Function() operation, {int maxRetries = 2}) async {
    int attempt = 0;
    
    while (attempt <= maxRetries) {
      try {
        await _checkRateLimit();
        return await operation();
      } catch (e) {
        final errorStr = e.toString();
        
        if (errorStr.contains('quota') || 
            errorStr.contains('RESOURCE_EXHAUSTED') ||
            errorStr.contains('429')) {
          
          if (kDebugMode) {
            print('‚ö†Ô∏è Quota exceeded on attempt ${attempt + 1}');
          }
          
          // Try rotating to next API key
          if (attempt < maxRetries) {
            final oldKey = ApiConfig.geminiApiKey;
            ApiConfig.rotateApiKey();
            final newKey = ApiConfig.geminiApiKey;
            
            if (oldKey != newKey) {
              if (kDebugMode) {
                print('üîÑ Rotated to new API key. Retrying...');
              }
              
              // Reinitialize with new key
              await initialize();
              attempt++;
              await Future.delayed(const Duration(seconds: 2));
              continue;
            } else {
              // No more keys to rotate to
              throw Exception('quota_exceeded_all_keys');
            }
          }
        }
        
        // Re-throw if not quota error or max retries reached
        rethrow;
      }
    }
    
    throw Exception('Max retries exceeded');
  }

  // ========== Load Full Document ==========
  Future<void> loadDocument(String fileName, Uint8List fileBytes, String mimeType) async {
    if (_model == null) await initialize();

    _isLoading = true;
    notifyListeners();

    try {
      await _executeWithRetry(() async {
        // 1. Start fresh for new file
        _conversationHistory.clear();
        _chatSession = _model!.startChat();

        final systemPrompt = AIPrompts.getSystemPrompt(_currentPersonality);
        
        // 2. Analyze document
        final analysisContent = Content.multi([
          TextPart("""$systemPrompt

[TASK 1]: Analyze this entire PDF document and provide:
1. COMPREHENSIVE NOTES: A detailed summary of the entire document covering all key topics, concepts, and important points
2. KEY DEFINITIONS: Define all important terms, technical words, and concepts found in the document

Format your response EXACTLY as follows:

===NOTES===
[Write comprehensive notes here covering the entire document]

===DEFINITIONS===
Term 1: Definition
Term 2: Definition
Term 3: Definition
[etc.]

===END===

Document name: '$fileName'
"""),
          DataPart(mimeType, fileBytes),
        ]);

        final analysisResponse = await _chatSession!.sendMessage(analysisContent);
        final analysisText = analysisResponse.text ?? '';
        
        // Parse notes and definitions
        _parseNotesAndDefinitions(analysisText);
        
        // 3. Set up Q&A mode
        final setupContent = Content.text(
          "[SYSTEM INSTRUCTION]: The document has been analyzed. Now switch to Q&A mode. "
          "When the user asks questions, reference the page number they provide and answer based on the document content."
        );
        await _chatSession!.sendMessage(setupContent);
        
        _hasDocumentLoaded = true;
        _loadedFileName = fileName;
        
        // 4. Add welcome message
        _conversationHistory.add(ChatMessage.ai(
          "‚úÖ I've analyzed **$fileName**\n\n"
          "üìö **Comprehensive notes** and **key definitions** are ready!\n"
          "üí¨ Ask me anything about the document, and I'll help you understand it.",
          _currentPersonality.displayName
        ));
      });

      _isLoading = false;
      notifyListeners();

    } catch (e) {
      _isLoading = false;
      
      String errorMsg = e.toString();
      if (errorMsg.contains('quota_exceeded_all_keys')) {
        _errorMessage = "‚ö†Ô∏è All API keys have exceeded their quota.";
        _conversationHistory.add(ChatMessage.error(
          "‚ö†Ô∏è **All API keys exhausted**\n\n"
          "**Solutions:**\n"
          "1. Wait 1-2 hours\n"
          "2. Add more free API keys (see instructions)\n"
          "3. The free tier allows 1500 requests/day per key\n\n"
          "üìù Get free keys at: https://aistudio.google.com/apikey"
        ));
      } else if (errorMsg.contains('quota') || errorMsg.contains('RESOURCE_EXHAUSTED')) {
        _errorMessage = "‚ö†Ô∏è API quota exceeded.";
        _conversationHistory.add(ChatMessage.error(
          "‚ö†Ô∏è **API Quota Exceeded**\n\n"
          "The current API key has reached its daily limit.\n\n"
          "**Quick Fix:**\n"
          "Add more free API keys to the app.\n"
          "Each Google account gets 1500 free requests/day!\n\n"
          "üìù Get keys at: https://aistudio.google.com/apikey"
        ));
      } else if (errorMsg.contains('API key')) {
        _errorMessage = "‚ö†Ô∏è Invalid API key.";
        _conversationHistory.add(ChatMessage.error(
          "‚ö†Ô∏è Invalid API key. Please check your configuration."
        ));
      } else {
        _errorMessage = "Failed to process file: $errorMsg";
        _conversationHistory.add(ChatMessage.error(
          "‚ùå Failed to process the document. Error: $errorMsg"
        ));
      }
      
      notifyListeners();
    }
  }

  // ========== Parse Notes and Definitions ==========
  void _parseNotesAndDefinitions(String response) {
    try {
      final notesRegex = RegExp(r'===NOTES===(.*?)===DEFINITIONS===', dotAll: true);
      final notesMatch = notesRegex.firstMatch(response);
      if (notesMatch != null) {
        _documentNotes = notesMatch.group(1)?.trim() ?? '';
      }

      final definitionsRegex = RegExp(r'===DEFINITIONS===(.*?)===END===', dotAll: true);
      final defsMatch = definitionsRegex.firstMatch(response);
      if (defsMatch != null) {
        final defsText = defsMatch.group(1)?.trim() ?? '';
        final lines = defsText.split('\n');
        
        _definitions.clear();
        for (final line in lines) {
          if (line.contains(':')) {
            final parts = line.split(':');
            if (parts.length >= 2) {
              final term = parts[0].trim();
              final definition = parts.sublist(1).join(':').trim();
              if (term.isNotEmpty && definition.isNotEmpty) {
                _definitions[term] = definition;
              }
            }
          }
        }
      }

      if (kDebugMode) {
        print('üìù Extracted ${_documentNotes.length} chars of notes');
        print('üìñ Extracted ${_definitions.length} definitions');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ö†Ô∏è Error parsing notes/definitions: $e');
      }
    }
  }

  // ========== Send Message with Context ==========
  Future<void> sendMessage(String userMessage, {int? currentPage}) async {
    if (_model == null) await initialize();
    if (userMessage.trim().isEmpty) return;
    
    _isLoading = true;
    notifyListeners();
    
    try {
      await _executeWithRetry(() async {
        _emotionDetection.detectEmotion(userMessage);

        _conversationHistory.add(ChatMessage.user(userMessage));
        notifyListeners();
        
        String fullPrompt = userMessage;
        if (_hasDocumentLoaded && currentPage != null) {
          fullPrompt = "I am currently looking at Page ${currentPage + 1}. $userMessage";
        }

        final response = await _chatSession!.sendMessage(Content.text(fullPrompt));
        final aiResponse = response.text ?? "I'm not sure how to answer that.";
        
        _conversationHistory.add(ChatMessage.ai(
          aiResponse,
          _currentPersonality.displayName,
        ));
      });
      
    } catch (e) {
      String errorMsg = e.toString();
      if (errorMsg.contains('quota_exceeded_all_keys')) {
        _conversationHistory.add(ChatMessage.error(
          "‚ö†Ô∏è All API keys exhausted. Please add more keys or wait 1-2 hours."
        ));
      } else if (errorMsg.contains('quota') || errorMsg.contains('RESOURCE_EXHAUSTED')) {
        _conversationHistory.add(ChatMessage.error(
          "‚ö†Ô∏è API quota exceeded. Rotating keys... Please try again."
        ));
      } else {
        _conversationHistory.add(ChatMessage.error("‚ùå Error: $errorMsg"));
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void setStateService(ConversationStateService service) {
    _stateService = service;
  }
  
  Future<bool> resumeConversation() async {
      return false; 
  }

  void switchPersonality(AIPersonality newPersonality) {
    _currentPersonality = newPersonality;
    if (_chatSession != null) {
      _chatSession!.sendMessage(Content.text(
        "SYSTEM: Switch personality to ${newPersonality.displayName}. Keep the document in memory."
      ));
    }
    notifyListeners();
  }

  void clearConversation() {
    _conversationHistory.clear();
    _hasDocumentLoaded = false;
    _loadedFileName = null;
    _documentNotes = '';
    _definitions.clear();
    _chatSession = _model!.startChat();
    notifyListeners();
  }
  
  // Get usage statistics
  Map<String, dynamic> getUsageStats() {
    return ApiConfig.getUsageStats();
  }
}